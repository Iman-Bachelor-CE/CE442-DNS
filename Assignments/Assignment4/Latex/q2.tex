\section*{جواب سوال ۲}

\subsection*{بخش اول}

وقتی یک پیام
\lr{m}
ابتدا توسط الگوریتم فشرده‌سازی
\lr{C(m)}
فشرده می‌شود و سپس با استفاده از رمزنگاری بلوکی با اندازه بلوک ۸ بیت پد شده و رمزگذاری می‌گردد، طول نهایی پیام رمزگذاری شده مستقیماً به طول پیام فشرده شده
\lr{C(m)}
بستگی دارد. مهاجم که تنها تعداد بلوک‌های ارسال شده را مشاهده می‌کند، می‌تواند اطلاعاتی درباره طول
\lr{C(m)}
به دست آورد. از آنجایی که طول 
\lr{C(m)}
نشان‌دهنده تعداد و طول رشته‌های 1 متوالی در پیام اصلی
\lr{m}
است، مهاجم می‌تواند استنتاج‌هایی درباره الگوی تکراری در m انجام دهد.

با یک مثال درباره‌ی این مورد بیشتر توضیح می‌دهم. \textbf{مثال:}

پیام $m_{1}$: 1111111111011111010111

$C(m_{1}) = 1010010100010011$

طول $C(m_{1}) = 16$ بیت $\rightarrow$ ۲ بلوک ۸ بیتی

پیام $m_{2}$: 1111101111101111101111

$C(m_{2})$ ممکن است طول بیشتری داشته باشد (فرضاً 24 بیت) $\rightarrow$ ۳ بلوک ۸ بیتی

در این حالت، اگر مهاجم مشاهده کند که دو بلوک ارسال شده‌اند، احتمال می‌دهد پیام $m_{1}$ با الگوی تکراری مناسب فشرده شده است. اگر سه بلوک ارسال شود، ممکن است پیام $m_{2}$ با الگوی کمتر تکراری فشرده شده باشد.

مهاجم می‌تواند از تفاوت‌های فشرده‌سازی بین دو پیام با طول اصلی برابر استفاده کند تا تشخیص دهد کدام پیام رمزگذاری شده است. اگر دو پیام $m_{1}$ و $m_{2}$ دارای طول اصلی یکسان باشند اما الگوهای متفاوتی از رشته‌های 1 متوالی داشته باشند، فشرده‌سازی آن‌ها نیز متفاوت خواهد بود. پیام با الگوی فشرده‌تر (بیشتر رشته‌های تکراری و طولانی‌تر 1ها) منجر به $C(m)$ کوتاه‌تر و در نتیجه تعداد بلوک‌های کمتر خواهد شد.

با یک مثال درباره‌ی این مورد بیشتر توضیح می‌دهم. \textbf{مثال:}

پیام $m_{1}$: 1111111111011111010111

$C(m_{1}) = 1010010100010011$

تعداد بلوک‌های رمزگذاری شده: ۲ بلوک

پیام $m_{2}$: 1111101111101111101111

$C(m_{2}) = 1010101001010101$

تعداد بلوک‌های رمزگذاری شده: ۳ بلوک

در این حالت، اگر مهاجم مشاهده کند که تعداد بلوک‌های رمزگذاری شده ۲ بلوک است، نتیجه می‌گیرد که پیام $m_{1}$ رمزگذاری شده است. اگر ۳ بلوک مشاهده کند، نتیجه می‌گیرد که پیام $m_{2}$ رمزگذاری شده است.

این روش به مهاجم اجازه می‌دهد تا با تحلیل طول پیام‌های رمزگذاری شده و مقایسه آن‌ها با الگوهای مختلف فشرده‌سازی، اطلاعاتی درباره محتوای پیام اصلی بدست آورد. این نوع حمله نشان‌دهنده آسیب‌پذیری‌های احتمالی در ترکیب فشرده‌سازی و رمزنگاری است که پس از حملات 
\lr{CRIME}
 در پروتکل‌های جدید مانند
\lr{TLS 1.3}
حذف شده‌اند تا از چنین تهدیداتی جلوگیری شود.

\subsection*{بخش دوم}

در این بخش، مهاجم توانایی افزودن بیت‌های دلخواه به ابتدای پیام‌های اصلی را دارد و با انجام این کار، می‌خواهد تعداد 1های رشته اول پیام
\lr{m}
را کشف کند. برای این منظور، مهاجم از ویژگی‌های الگوریتم فشرده‌سازی بی‌اتلاف
\lr{C(m)}
استفاده می‌کند که تعداد 1 های هر رشته را به صورت یک مقدار ۴ بیتی نمایش می‌دهد و محدودیت‌هایی در تعداد 1 های متوالی دارد.

\subsubsection*{روش حمله}

\textbf{افزودن بیت‌های کنترل‌شده به ابتدای پیام}

مهاجم می‌تواند به تعداد دلخواه بیت‌های 1 یا 0 را به ابتدای پیام m اضافه کند. هدف این است که با تنظیم تعداد بیت‌های 1 اضافه شده، تغییراتی در فشرده‌سازی رخ دهد که به کمک آن بتوان تعداد 1های رشته اول m را تعیین کرد.

\textbf{تعیین نقطه تغییر در فشرده‌سازی}

از آنجا که الگوریتم فشرده‌سازی
\lr{C(m)}
فقط تا پانزده 1 متوالی را به درستی فشرده می‌کند و اگر تعداد 1 ها بیشتر از ۱۵ شود، فقط پانزده 1 اول را فشرده می‌کند و بقیه را نادیده می‌گیرد، مهاجم می‌تواند با افزایش تدریجی تعداد 1 های اضافه شده، نقطه‌ای را پیدا کند که در آن تعداد 1 های متوالی به ۱۵ برسد.

\textbf{تحلیل تعداد بلوک‌های رمزگذاری شده}

پس از افزودن بیت‌های کنترل‌شده و فشرده‌سازی پیام، پیام فشرده شده به بلوک‌های ۸ بیتی تقسیم می‌شود و رمزگذاری می‌گردد. تعداد بلوک‌های رمزگذاری شده به طور مستقیم به طول پیام فشرده شده بستگی دارد. مهاجم با مشاهده تعداد بلوک‌ها می‌تواند تشخیص دهد که آیا تعداد 1 های متوالی افزوده شده به m به ۱۵ رسیده یا نه.

\textbf{گام‌های دقیق حمله}

ابتدا یک سری فرضیات اولیه داریم.

\begin{itemize}[label=--]
	\item فرض کنید پیام اصلی m با k عدد 1 در ابتدای آن شروع می‌شود.
	\item مهاجم قصد دارد تعداد 1های k را تعیین کند.
\end{itemize}

\textbf{افزودن بیت‌های 1 کنترل‌شده}
مهاجم به ترتیب از
$t = 0$
تا
$t = 15$
بیت 1 به ابتدای پیام m اضافه می‌کند، یعنی پیام‌های زیر را ارسال می‌کند:

\begin{itemize}[label=--]
	\item $t = 0: m$
	\item $t = 1: 1m$
	\item $t = 2: 11m$
	\item \dots
	\item $t = 15: 111111111111111m$
\end{itemize}

\textbf{مشاهده تعداد بلوک‌های رمزگذاری شده}
برای هر مقدار t ، مهاجم تعداد بلوک‌های رمزگذاری شده را مشاهده می‌کند.

\subsubsection*{تجزیه و تحلیل تغییرات}

\begin{itemize}[label=--]
	\item
اگر $t + k \leq 15$ باشد: تعداد 1های متوالی در پیام فشرده شده برابر با $t + k$ است و فشرده‌سازی به طور بهینه انجام می‌شود.
	\item
اگر $t + k > 15$ باشد: فشرده‌سازی فقط پانزده 1 اول را در نظر می‌گیرد و بقیه نادیده می‌گیرد، که منجر به افزایش طول پیام فشرده شده و در نتیجه افزایش تعداد بلوک‌های رمزگذاری شده می‌شود.
\end{itemize}

\subsubsection*{تعیین تعداد 1 های اولیه (k)}
مهاجم به دنبال کمترین مقداری از t است که در آن
$t + k > 15$
می‌شود. این نقطه تغییر نشان‌دهنده آن است که $k = 16 - t$. بنابراین، با یافتن مقداری از t که در آن تعداد بلوک‌های رمزگذاری شده افزایش می‌یابد، مهاجم می‌تواند مقدار k را محاسبه کند.

حالا برای مثال بدین شکل داریم:

فرض کنید پیام اصلی m با
$k = 10$
عدد 1 شروع می‌شود:

\subsubsection*{افزودن $t = 0$ بیت 1}
\begin{itemize}[label=--]
	\item پیام تغییر یافته: m (10 عدد 1 متوالی)
	\item تعداد 1های فشرده شده: ۱۰
	\item تعداد بلوک‌های رمزگذاری شده: به عنوان مثال، ۲ بلوک
\end{itemize}

\subsubsection*{افزودن $t = 5$ بیت 1}
\begin{itemize}[label=--]
	\item پیام تغییر یافته: 11111m (5 + 10 = 15 عدد 1 متوالی)
	\item تعداد 1های فشرده شده: ۱۵
	\item تعداد بلوک‌های رمزگذاری شده: همچنان ۲ بلوک
\end{itemize}

\subsubsection*{افزودن $t = 6$ بیت 1}
\begin{itemize}[label=--]
	\item پیام تغییر یافته: 111111m (6 + 10 = 16 عدد 1 متوالی)
	\item تعداد 1های فشرده شده: فقط ۱۵ عدد 1 اول
	\item تعداد بلوک‌های رمزگذاری شده: افزایش به ۳ بلوک
\end{itemize}

با مشاهده افزایش تعداد بلوک‌ها زمانی که $t = 6$ است، مهاجم می‌داند که
$t + k = 16$
از این رو
$k = 16 - 6 = 10$

\subsubsection*{نتیجه‌ی بخش دوم}
با استفاده از افزودن بیت‌های کنترل‌شده به ابتدای پیام و تحلیل تغییرات در تعداد بلوک‌های رمزگذاری شده، مهاجم قادر است تعداد 1 های متوالی در ابتدای پیام اصلی m را به طور دقیق تعیین کند. این روش نشان‌دهنده آسیب‌پذیری ترکیب فشرده‌سازی و رمزگذاری در پروتکل‌های امنیتی مشابه
\lr{TLS 1.2}
است که منجر به حملاتی مانند
\lr{CRIME}
شده است. به همین دلیل، در نسخه‌های جدیدتر مانند 
\lr{TLS 1.3}
، قابلیت فشرده‌سازی حذف شده تا از چنین حملاتی جلوگیری شود.

\subsection*{بخش سوم}

حمله
\lr{CRIME (Compression Ratio Info-leak Made Easy)}
یک حمله جانبی
\lr{(side-channel attack)}
علیه پروتکل‌های امنیتی مانند TLS است که از ویژگی فشرده‌سازی داده‌ها سوء استفاده می‌کند. در این حمله، مهاجم با استفاده از قابلیت فشرده‌سازی و مشاهده تغییرات در طول داده‌های رمزگذاری‌شده، می‌تواند اطلاعات حساس مانند کوکی‌های کاربر را به‌دست آورد.

\subsection*{شرایط لازم برای موفقیت حمله \lr{CRIME}}

\subsubsection*{فعال بودن فشرده‌سازی در ارتباط \lr{TLS}}
پروتکل \lr{TLS} باید قابلیت فشرده‌سازی داده‌ها را فعال کرده باشد. در نسخه‌های قدیمی‌تر مانند \lr{TLS 1.2} این ویژگی وجود دارد، در حالی که در نسخه‌های جدیدتر مانند \lr{TLS 1.3} به منظور جلوگیری از حملات مشابه \lr{CRIME}، فشرده‌سازی حذف شده است.

\subsubsection*{توانایی مهاجم در تزریق داده به جریان اطلاعات}
مهاجم باید بتواند داده‌هایی را به جریان اطلاعاتی که بین کاربر و سرور رد و بدل می‌شود، اضافه کند. این معمولاً از طریق ضعف‌های موجود در مرورگرها یا کاربردهای مبتنی بر وب انجام می‌گیرد.

\subsubsection*{قابلیت مشاهده طول داده‌های رمزگذاری‌شده}
مهاجم باید بتواند طول داده‌های رمزگذاری‌شده را قبل و بعد از فشرده‌سازی مشاهده کند. این اطلاعات به او کمک می‌کند تا تغییرات در فشرده‌سازی را تحلیل کند.

\subsection*{نحوه انجام حمله CRIME}

\subsubsection*{تزریق داده‌های کنترل‌شده}
مهاجم داده‌های خاصی را به درخواست‌های HTTP ارسال می‌کند که در کنار کوکی‌های کاربر قرار می‌گیرند. هدف این است که داده‌های تزریق‌شده با بخش‌های مخفی (مانند کوکی‌ها) تکراری شوند.

\subsubsection*{تحلیل تغییرات در طول فشرده‌سازی}
زمانی که داده‌های تزریق‌شده با کوکی‌ها تکراری باشند، الگوریتم فشرده‌سازی می‌تواند این تکرارها را به‌طور موثرتری فشرده کند، که منجر به کاهش طول داده‌های رمزگذاری‌شده می‌شود. مهاجم با مقایسه طول‌های مختلف داده‌های رمزگذاری‌شده برای حدس‌های مختلف، می‌تواند تشخیص دهد که کدام حدس‌ها صحیح هستند.

\subsubsection*{بازسازی کوکی‌ها به صورت مرحله‌ای}
مهاجم به صورت تدریجی و با حدس‌های ترتیبی، بخش‌های مختلف کوکی را بازسازی می‌کند. هر بار که یک حدس صحیح باشد، کاهش قابل‌توجهی در طول داده‌های فشرده‌شده مشاهده می‌شود که به مهاجم نشان می‌دهد که آن بخش از کوکی صحیح حدس زده شده است.

حالا در یک مثال این مورد رو بررسی می‌کنم.

فرض کنید کوکی کاربر شامل رشته‌ای مخفی مانند \lr{session id=ABC123} است:

\subsection*{تزریق داده‌های کنترل‌شده توسط مهاجم}
مهاجم داده‌هایی مانند \lr{A}, \lr{AB}, \lr{ABC} و ... را به ابتدای درخواست‌های HTTP اضافه می‌کند.

\subsection*{تحلیل تغییرات طول داده‌های رمزگذاری‌شده}
هر بار که یک بخش از حدس‌های مهاجم با کوکی واقعی مطابقت داشته باشد (مثلاً \lr{A} با \lr{A} یا \lr{AB} با \lr{AB}), فشرده‌سازی بهینه‌تر انجام شده و طول داده‌های رمزگذاری‌شده کاهش می‌یابد.

\subsection*{بازسازی کامل کوکی}
مهاجم با تحلیل این تغییرات طول، به تدریج می‌تواند کل کوکی را بازسازی کند.

حمله CRIME نشان‌دهنده آسیب‌پذیری‌های ترکیب فشرده‌سازی و رمزنگاری در پروتکل‌های امنیتی است. با حذف قابلیت فشرده‌سازی در نسخه‌های جدیدت